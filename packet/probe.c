/*
    mtr  --  a network diagnostic tool
    Copyright (C) 2016  Matt Kimball

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
    published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#include "probe.h"

#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#include "platform.h"
#include "protocols.h"
#include "timeval.h"

#define IP_TEXT_LENGTH 32

/*  Convert the destination address from text to sockaddr  */
int decode_dest_addr(
    const struct probe_param_t *param,
    struct sockaddr_in *dest_sockaddr)
{
    struct in_addr dest_addr;

    if (param->ipv4_address == NULL) {
        return EINVAL;
    }

    if (inet_pton(AF_INET, param->ipv4_address, &dest_addr) != 1) {
        return EINVAL;
    }

    dest_sockaddr->sin_family = AF_INET;
    dest_sockaddr->sin_port = 0;
    dest_sockaddr->sin_addr = dest_addr;

    return 0;
}

/*  Allocate a structure for tracking a new probe  */
struct probe_t *alloc_probe(
    struct net_state_t *net_state,
    int token)
{
    int i;
    struct probe_t *probe;

    for (i = 0; i < MAX_PROBES; i++) {
        probe = &net_state->probes[i];

        if (!probe->used) {
            memset(probe, 0, sizeof(struct probe_t));

            probe->used = true;
            probe->token = token;

            return probe;
        }
    }

    return NULL;
}

/*  Mark a probe tracking structure as unused  */
void free_probe(
    struct probe_t *probe)
{
    probe->used = false;
}

/*
    Return the number of probes which haven't yet received a reply
    and haven't yet timed out.
*/
int count_in_flight_probes(
    struct net_state_t *net_state)
{
    int i;
    int count;
    struct probe_t *probe;

    count = 0;
    for (i = 0; i < MAX_PROBES; i++) {
        probe = &net_state->probes[i];

        if (probe->used) {
            count++;
        }
    }

    return count;
}

/*
    Find an existing probe structure by ICMP id and sequence number.
    Returns NULL if non is found.
*/
struct probe_t *find_probe(
    struct net_state_t *net_state,
    int icmp_id,
    int icmp_sequence)
{
    int i;
    struct probe_t *probe;

    /*
        If the ICMP id doesn't match our process ID, it wasn't a
        probe generated by this process, so ignore it.
    */
    if (icmp_id != htons(getpid())) {
        return NULL;
    }

    for (i = 0; i < MAX_PROBES; i++) {
        probe = &net_state->probes[i];

        if (probe->used && htons(probe->token) == icmp_sequence) {
            return probe;
        }
    }

    return NULL;
}

/*
    After a probe reply has arrived, respond to the command request which
    sent the probe.
*/
void respond_to_probe(
    struct probe_t *probe,
    int icmp_type,
    struct sockaddr_in remote_addr,
    unsigned int round_trip_us)
{
    char ip_text[IP_TEXT_LENGTH];
    const char *result;

    if (inet_ntop(
            AF_INET, &remote_addr.sin_addr,
            ip_text, IP_TEXT_LENGTH) == NULL) {

        perror("inet_ntop failure");
        exit(1);
    }

    if (icmp_type == ICMP_TIME_EXCEEDED) {
        result = "ttl-expired";
    } else {
        assert(icmp_type == ICMP_ECHOREPLY);
        result = "reply";
    }

    printf(
        "%d %s ip-4 %s round-trip-time %d\n",
        probe->token, result, ip_text, round_trip_us);

    free_probe(probe);
}
